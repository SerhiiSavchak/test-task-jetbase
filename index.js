// Решение номер 1

const getMissingNumbersByObject = (arr, n) => {
  // Создаем объект для хранения всех чисел в последовательности, проходимся циклом от 1 до n, на каждом шаге итерации создаем ключ обьекта равный i с дефолтным значением false
  const numbersList = {};
  for (let i = 1; i <= n; i++) {
    numbersList[i] = false;
  }

  // Перебираем массив чисел и ставим в нашем обьекте значение true для тех чисел, которые присутствуют в данном масиве
  arr.forEach((num) => {
    numbersList[num] = true;
  });

  // Еще раз создаем цикл от 1 до n и проверяем: если у числа в нашем обьекте стоит значение false, значит оно - отсутсвует, добавляем его в массив missingNumbers
  const missingNumbers = [];
  for (let i = 1; i <= n; i++) {
    !numbersList[i] && missingNumbers.push(i);
  }

  return missingNumbers;
};

// Оценка вычислительной сложности - в данной функции мы 3 раза проходимся циклом по длинне от 1 до n(2 раза используя цикл for и 1 раз метод forEach), что в целом оптимально, учитывая данную задачу, но это не самый декларативный и оптимизорованый способ.

// Пример использования для массива от 1 до 10
const arr = [1, 3, 4, 5, 6, 7, 9, 10];

const n = 10; //Последнее число в масиве

console.log("Ожидаемый вывод", getMissingNumbersByObject(arr, n)); //Ожидаемый вывод [2,8]

// Решение номер 2

const getMissingNumbersBySet = (arr, n) => {
  // Создаем Set для хранения присутствующих чисел в данном нам массиве
  const numberSet = new Set(arr);

  // Создаем массив  чисел в последовательности  от 1 до n , проходим по каждому числу методом filter и проверяем, если его нет в set коллекции, значит это - вытянутое число, сохраняем его в missingNumbers

  const missingNumbers = Array.from({ length: n }, (_, i) => i + 1).filter(
    (num) => !numberSet.has(num)
  );

  return missingNumbers;
};

// Оценка вычислительной сложности - в данной функции мы 3 раза проходимся циклом по длинне от 1 до n(при создании Set, при создании массива с помощью Array.from, при фильтрации массива с помощью filter),  учитывая данную задачу, вычислительная сложность данной функции такая же, как и предидущего решения, но  данное решение более декларативное и, так как set более оптимизирован для операций перебора, данное решение я считаю лучшим

// Пример использования для массива от 1 до 20
const arrTwo = [
  1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
];
const nTwo = 20; //Последнее число в масиве
console.log("Ожидаемый вывод 2", getMissingNumbersBySet(arrTwo, nTwo)); //Ожидаемый вывод [5,9]
